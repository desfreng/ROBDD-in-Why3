module SAT
  use robdd.BDD
  use robdd.Size
  use seq.Seq
  use set.Fset
  use mach.int.Int63
  use int.Int
  use mach.array.Array63

  let rec lemma value_match (hc : hctable) (u v : affectation) (b : bdd) =
    requires { well_formed hc.tbl b }
    requires { is_node b -> forall y : int63. y >= var b -> u y  = v y }
    ensures { value u b = value v b }
    variant  { b }
    if is_leaf b then ()
    else
      if u (var b) then
        value_match hc u v (true_branch b)
      else
        value_match hc u v (false_branch b)

  predicate sat (b : bdd) =
    exists f : affectation. value f b = True

  lemma top_is_sat:
    sat Top
    by value (fun _ -> False) Top = True

  let rec lemma nodes_are_sat (hc : hctable) (b : bdd) : affectation =
    requires { mem_tbl hc.tbl b }
    ensures {
    value result b = True }
    variant { b }
    match b with
      | N v Bottom f _ ->
          match f with
            | Top -> (fun _ -> False)
            | Bottom -> absurd
            | N _ _ _ _ ->  let u = nodes_are_sat hc f in (fun x -> if x = v then False else u x)
          end
      | N v t _ _ ->
          match t with
            | Top -> (fun _ -> True)
            | Bottom -> absurd
            | N _ _ _ _ -> let u = nodes_are_sat hc t in (fun x -> if x = v then True else u x)
          end
      | _ -> absurd
    end

  let predicate is_sat (ghost hc : hctable) (b : bdd) =
    requires { well_formed hc.tbl b }
    ensures { result <-> sat b }
    match b with
      | Bottom -> False
      | Top | N _ _ _ _ -> True
    end

  (* Predicate to get the value of a BDD with an array *)
  let rec ghost predicate array_value (sol : array bool) (b : bdd) =
    requires { var_bounded_bdd sol.length b }
    variant { b }
    match b with
      | Top -> True
      | Bottom -> False
      | N v t f _ -> if sol[v] then array_value sol t else array_value sol f
    end
    
  let rec lemma array_value_same_eval (b : bdd) (sol : array bool) (affect : affectation) =
    requires { var_bounded_bdd sol.length b }
    requires { forall x : int63. 0 <= x < sol.length -> sol[x] = affect x }
    ensures { array_value sol b <-> value affect b }
    variant { b }
    match b with 
      | Top | Bottom -> ()
      | N v t f _ -> if sol[v] then array_value_same_eval t sol affect else array_value_same_eval f sol affect
    end
    
  (* Give an affectation for each var in [0; n[ that satisfy the bdd. *)
  let any_sat (ghost hc : hctable) (n : int63) (b : bdd) : array bool =
    (* Well-formed bdd *)
    requires { well_formed hc.tbl b }

    (* All the variable are in [0; n [ *)
    requires { var_bounded_bdd n b }

    (* n >=0 *)
    requires { n >= 0 }

    (* If b is sat, the result is an affectation that satisfy the bdd *)
    ensures { sat b -> array_value result b = True }

    let sol = Array63.make n False in
    let rec _loop (u : bdd) =
      (* Well-formed BDD *)
      requires { well_formed hc.tbl u }

      (* All the variable are in [0; n [ *)
      requires { var_bounded_bdd n u }

      (* u is a subnodes of b or u is Top *)
      requires { u = Top \/ mem u (subnodes b) }

      (* All the cell between (var u) and n are set to False
         (No modification of the array is this range has been made) *)
      requires { forall x : int. is_node u -> n > x >= var u -> sol[x] = False }

      (* This build a correct affectation that satisfy u *)
      ensures { array_value sol u }

      (* If u is a node, all the modification before our variable are kept *)
      ensures { forall x : int63. is_node u -> 0 <= x < var u -> (old sol)[x] = sol[x] }

      (* We do not modify the array if u = Top *)
      ensures { u = Top -> old sol = sol }

      variant { u }
      match u with
        | Top -> ()
        | Bottom -> absurd
        | N v t Bottom _ -> sol[v] <- True; _loop t
        | N _ _ f _ -> _loop f
      end
    in
    if is_node b then _loop b;
    sol
end


module CountSat
  use robdd.BDD
  use robdd.Size
  use mach.int.Int63
  use set.Fset
  use seq.Seq
  use seq.FreeMonoid
  use int.Int
  use robdd.BDDAssociationMap as MemoMap
  
  (* Predicate to get the value of a BDD with a sequence *)
  let rec ghost predicate seq_value (sol : seq bool) (b : bdd) =
    requires { var_bounded_bdd sol.length b }
    variant { b }
    match b with
      | Top -> True
      | Bottom -> False
      | N v t f _ -> if sol[Int63.to_int v] then seq_value sol t else seq_value sol f
    end
  
  
  (* seq_value and value give the same output for similar affectation *)
  let rec lemma array_value_same_eval (b : bdd) (sol : seq bool) (affect : affectation) =
    requires { var_bounded_bdd sol.length b }
    requires { forall x : int63. 0 <= x < sol.length -> sol[x] = affect x }
    ensures { seq_value sol b <-> value affect b }
    variant { b }
    match b with 
      | Top | Bottom -> ()
      | N v t f _ -> if sol[Int63.to_int v] then array_value_same_eval t sol affect else array_value_same_eval f sol affect
    end
  
  (* build all the interpretation satifying a BDD *)
  let rec ghost function all_sat (hc : hctable) (nb_var : int) (v_id : int) (a : seq bool) (b : bdd) : fset (seq bool) = 
    (* v_id is in [0; nb_var] *)
    requires { nb_var >= v_id >= 0 }
    
    (* All variable are < than nb_var *)
    requires { var_bounded_bdd nb_var b }

    (* b is well-formed *)
    requires { well_formed hc.tbl b }
    
    (* If b is a node, var b >= v_id *)
    requires { is_node b -> v_id <= var b }
    
    (* a is of length max_var *)
    requires { a.length = nb_var }
    
    (* The size of all the sequences in the result is max_var - v_id *)
    ensures { forall u : seq bool. mem u result -> u.length = nb_var }
    
    (* All sequences in the result satisfies b *)
    ensures { forall u : seq bool. mem u result -> seq_value u b = True }
    
    (* All sequences have the same begining as a *)
    ensures { forall u : seq bool. mem u result -> forall i : int. 0 <= i < v_id -> a[i] = u[i] }
    
    (* If u is a sequences satifying b then u is in result *)
    ensures { forall u : seq bool. u.length = nb_var -> seq_value u b = True -> (forall i : int. 0 <= i < v_id -> a[i] = u[i]) -> mem u result }
    
    variant { nb_var - v_id }
    match b with
      | Bottom -> Fset.empty
      | Top ->
          if nb_var = v_id then
            (Fset.singleton a)
          else
            let b_true = set a v_id True in
            let b_false = set a v_id False in 
            Fset.union (all_sat hc nb_var (v_id + 1) b_true b) (all_sat hc nb_var (v_id + 1) b_false b)
      | N v t f _ -> 
          let b_true = set a v_id True in
          let b_false = set a v_id False in
          if Int63.to_int v = v_id then
            Fset.union (all_sat hc nb_var (v_id + 1) b_true t) (all_sat hc nb_var (v_id + 1) b_false f)
          else
            Fset.union (all_sat hc nb_var (v_id + 1) b_true b) (all_sat hc nb_var (v_id + 1) b_false b)
    end

  function all_sat_of (hc : hctable) (nb_var : int) (b : bdd) : fset (seq bool) =
    all_sat hc nb_var 0 (Seq.create nb_var (fun _ -> False)) b
  
  (* All the affectation of nb_var variables that satisfies b are in 'all_sat_of' *)
  lemma all_sat_are_in_result_of_all_sat_fun :
    forall hc : hctable, nb_var : int, b : bdd. nb_var >= 0 -> var_bounded_bdd nb_var b -> mem_tbl hc.tbl b -> 
    forall u : seq bool. u.length = nb_var /\ seq_value u b = True <-> mem u (all_sat_of hc nb_var b)
  
  (* Return all the affectation of nb_var variables that satisfies b with a false beginning [0; var b[ *)
  let ghost function begin_false_all_sat_of (hc : hctable) (nb_var : int) (b : bdd) : fset (seq bool) =
    requires { nb_var >= 0 }
    requires { var_bounded_bdd nb_var b }
    requires { mem_tbl hc.tbl b }
    ensures { forall u : seq bool. u.length = nb_var /\ seq_value u b = True /\ (forall i : int. 0 <= i < var b -> u[i] = False) <-> mem u result }
    all_sat hc nb_var (Int63.to_int (var b)) (Seq.create nb_var (fun _ -> False)) b
    
  type memo = {hc : hctable; m : MemoMap.t int; ghost s : MemoMap.t (fset (seq bool)) ; nb_var : int63 }
  (* nb_var >= 0 *)
  invariant { nb_var >= 0 }
  
  (* Beeing in m <-> Beeing in s *)
  invariant { forall u : bdd. MemoMap.is_in m u <-> MemoMap.is_in s u }
  
  (* Top and Bottom are not in the Memoisation Table *)
  invariant { not MemoMap.is_in m Top /\ not MemoMap.is_in m Bottom }
  
  (* All keys have their id < hc.next_id *)
  invariant { forall u : bdd. MemoMap.is_in m u -> id u < hc.next_id }

  (* All keys are var_bounded by nb_var *)
  invariant { forall u : bdd. mem_tbl hc.tbl u -> MemoMap.is_in m u -> var_bounded_bdd nb_var u }

  (* All values in m are the cardinal of the fset in s *)
  invariant { forall u : bdd. mem_tbl hc.tbl u -> MemoMap.is_in m u -> MemoMap.val_of m u = cardinal (MemoMap.val_of s u) }
  
  (* All values in s are sets of sequences u that satifies their key of length nb_var with u[..var b] = False *)
  invariant { forall u : bdd. mem_tbl hc.tbl u -> MemoMap.is_in s u -> MemoMap.val_of s u = begin_false_all_sat_of hc nb_var u }
  
  by {hc = create_hctable (); m = MemoMap.create (); s = MemoMap.create (); nb_var = Int63.zero }
  

  let count_sat (ghost hc : hctable) (n : int63) (b : bdd) : int =
    (* b is well-formed in hc *)
    requires { well_formed hc.tbl b }
    
    (* All the variable of b are < n *)
    requires { var_bounded_bdd n b }
    
    (* Return the number of affectation that satisfies b *)
    ensures { result = cardinal (all_sat_of hc n b) }

    let memo = MemoMap.create () in
    let rec _loop (u : bdd) : int = 
(*      match u with
      | Bottom -> 0
      | Top ->
          if nb_var = v_id then
            (Fset.singleton a)
          else
            let b_true = set a v_id True in
            let b_false = set a v_id False in 
            Fset.union (all_sat hc nb_var (v_id + 1) b_true b) (all_sat hc nb_var (v_id + 1) b_false b)
      | N v t f _ -> 
          let b_true = set a v_id True in
          let b_false = set a v_id False in
          if Int63.to_int v = v_id then
            Fset.union (all_sat hc nb_var (v_id + 1) b_true t) (all_sat hc nb_var (v_id + 1) b_false f)
          else
            Fset.union (all_sat hc nb_var (v_id + 1) b_true b) (all_sat hc nb_var (v_id + 1) b_false b)
    end*) 0

    in
    _loop b

end
