module SAT
  use robdd.BDD
  use robdd.Size
  use seq.Seq
  use set.Fset
  use mach.int.Int63
  use int.Int
  use mach.array.Array63

  let rec lemma value_match (hc : hctable) (u v : affectation) (b : bdd) =
    requires { well_formed hc.tbl b }
    requires { is_node b -> forall y : int63. y >= var b -> u y  = v y }
    ensures { value u b = value v b }
    variant  { b }
    if is_leaf b then ()
    else
      if u (var b) then
        value_match hc u v (true_branch b)
      else
        value_match hc u v (false_branch b)

  predicate sat (b : bdd) =
    exists f : affectation. value f b = True

  lemma top_is_sat:
    sat Top
    by value (fun _ -> False) Top = True

  let rec lemma nodes_are_sat (hc : hctable) (b : bdd) : affectation =
    requires { mem_tbl hc.tbl b }
    ensures {
    value result b = True }
    variant { b }
    match b with
      | N v Bottom f _ ->
          match f with
            | Top -> (fun _ -> False)
            | Bottom -> absurd
            | N _ _ _ _ ->  let u = nodes_are_sat hc f in (fun x -> if x = v then False else u x)
          end
      | N v t _ _ ->
          match t with
            | Top -> (fun _ -> True)
            | Bottom -> absurd
            | N _ _ _ _ -> let u = nodes_are_sat hc t in (fun x -> if x = v then True else u x)
          end
      | _ -> absurd
    end

  let predicate is_sat (ghost hc : hctable) (b : bdd) =
    requires { well_formed hc.tbl b }
    ensures { result <-> sat b }
    match b with
      | Bottom -> False
      | Top | N _ _ _ _ -> True
    end

  (* All the variable of b are in [0; n [ *)
  predicate var_bounded_bdd (n : int) (b : bdd) =
    forall u : bdd. mem u (subnodes b) -> n > var u >= 0

  (* Predicate to get the value of a BDD with an array *)
  let rec ghost predicate array_value (sol : array bool) (b : bdd) =
    requires { var_bounded_bdd sol.length b }
    variant { b }
    match b with
      | Top -> True
      | Bottom -> False
      | N v t f _ -> if sol[v] then array_value sol t else array_value sol f
    end

  (* Give an affectation for each var in [0; n[ that satisfy the bdd. *)
  let any_sat (ghost hc : hctable) (n : int63) (b : bdd) : array bool =
    (* Well-formed bdd *)
    requires { well_formed hc.tbl b }

    (* All the variable are in [0; n [ *)
    requires { var_bounded_bdd n b }

    (* n >=0 *)
    requires { n >= 0 }

    (* If b is sat, the result is an affectation that satisfy the bdd *)
    ensures { sat b -> array_value result b = True }

    let sol = Array63.make n False in
    let rec _loop (u : bdd) =
      (* Well-formed BDD *)
      requires { well_formed hc.tbl u }

      (* All the variable are in [0; n [ *)
      requires { var_bounded_bdd n u }

      (* u is a subnodes of b or u is Top *)
      requires { u = Top \/ mem u (subnodes b) }

      (* All the cell between (var u) and n are set to False
         (No modification of the array is this range has been made) *)
      requires { forall x : int. is_node u -> n > x >= var u -> sol[x] = False }

      (* This build a correct affectation that satisfy u *)
      ensures { array_value sol u }

      (* If u is a node, all the modification before our variable are kept *)
      ensures { forall x : int63. is_node u -> 0 <= x < var u -> (old sol)[x] = sol[x] }

      (* We do not modify the array if u = Top *)
      ensures { u = Top -> old sol = sol }

      variant { u }
      match u with
        | Top -> ()
        | Bottom -> absurd
        | N v t Bottom _ -> sol[v] <- True; _loop t
        | N _ _ f _ -> _loop f
      end
    in
    if is_node b then _loop b;
    sol
end


module CountSat
  use robdd.BDD
  use mach.int.Int63
  use set.Fset
  use seq.Seq
  use int.Int
  use robdd.BDDAssociationMap as MemoMap
  use SAT
  
  function all_sat (n : int63) (b : bdd) : fset (seq bool) = 
    match b with
      | Bottom -> Fset.empty
      | Top -> Fset.singleton Seq.empty
      | N _ _ _ _ -> Fset.empty (* TODO *)
    end
  
  
  type memo = {hc : hctable; m : MemoMap.t int}
  (* Top and Bottom are not in the memoisation table *)
  invariant { not MemoMap.is_in m Top /\ not MemoMap.is_in m Bottom }

  invariant { forall u : bdd. MemoMap.is_in m u -> id u < hc.next_id }

  (* All values are images of the not operation of their key *)
  invariant { forall u : bdd. mem_tbl hc.tbl u -> MemoMap.is_in m u -> (MemoMap.val_of m u) = cardinal (all_sat Int63.zero u)  }
  
  by {hc = create_hctable (); m = MemoMap.create ()}
  

  let count_sat (ghost hc : hctable) (n : int63) (b : bdd) : int =
    requires { well_formed hc.tbl b }
    requires { var_bounded_bdd n b }
    ensures { result = cardinal (all_sat Int63.zero b) }

    let memo = MemoMap.create () in

    let rec _loop (u : bdd) : int =  0
    in
    _loop b

end